<!doctype html>
<html>
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

        <title>TypeScript Talk</title>

        <link rel="stylesheet" href="css/reveal.css">
        <link rel="stylesheet" href="css/theme/black.css">

        <!-- Theme used for syntax highlighting of code -->
        <link rel="stylesheet" href="lib/css/zenburn.css">
        <style>
            .reveal h2,
            .reveal h3,
            .reveal h4 {
                font-family: Verdana;
                color: #43ABC9;
            }

        </style>
        <!-- Printing and PDF exports -->
        <script>
            var link = document.createElement( 'link' );
            link.rel = 'stylesheet';
            link.type = 'text/css';
            link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
            document.getElementsByTagName( 'head' )[0].appendChild( link );
        </script>
    </head>
    <body>
        <!--
            For a newbie audience:
                What is a type system?
                What does it do for you?

                What does TypeScript do for you?
                Type Checking!

                Type Inference!
                control flow analysis
                syntax checking


                compiles es6 to es5 or es3
                module system

                gradual typing
                tuneable strictness

                refactor fearlessly
                speed up development
                types are documentation

                finding bugs before they get into production costs less

                dynamic type checking (runtime) vs static type checking (Compile time)

            For a more experienced audience:
              C & Java - Weak rigid inexpressive
              JavaScript - highly dynamic and expressive we don't want to lose that
              TypeScript - Has a powerful, expressive, and flexible type system to describe 


            To Cover:
            visual studio code
            numeric literal types
            true type
            false type

            *Tuple Types
            *Union Types
            *Intersection Types
            *Discriminated Unions
            *Enums
            *string literal types
            *structural type system vs Nominal Typing

            variance
            class static methods
            tsconfig
            typecast
            generics constraints
        -->
        <div class="reveal">
            <div class="slides">
                <section><h1>TypeScript</h1></section>
                <section>
                    <h2>What is it?</h2>
                    <p>
                    TypeScript, the language, is a strict superset of JavaScript ES6+ that adds a type system to JavaScript. It keeps all of the JavaScript syntax and features. </p>
                    <p>What TypeScript adds is the syntax to describe types of data, objects, classes, and functions.
                    </p>
                    <aside class="notes">
                        A common problem today is that es6 syntax and features are not available in old browsers. 
                        As a developer we want to take advantage of all this helpful new stuff but for cross compatilibity reasons we are constrained. You may have heard of the Babel compiled which translates es6 into older javascript. 
                        The TypeScript compiler does this as well. It can translate into es6, es5, and es3. 

                        On top of what babel does typescript does something more. 
                    </aside>
                </section>
                <section>
                    <h2>What is a type?</h2>
                    <p>According to wikipedia</p>
                    <p>
                    <b>
                        A data type is a classification of data which tells the compiler or interpreter how the programmer intends to use the data.
                    </b>
                    </p>
                    <aside class="notes">
                        It turns out that programming languages can be categorized into two groups, statically typed languages and dynamically typed languages. The big difference between is when is type information known. 
                        Either at run time, dynamic, or before the program is run. 

                        Dynamically typed: JavaScript, Ruby, Python, Perl, Php
                        Statically typed: C/C++,C#, objective C, Java, Scala, Go, Haskell, Swift
                    </aside>
                </section>
                <section>
                    <h2>Why should you care about types?</h2>
                    <p>
Type checking, the process of validating matching types in your programs, removes an entire category of bugs from your program by not allowing you to make them. Essentially, a type system is there to help you ensure correct code without even running your program.
                    </p>
                    <aside class="notes">
                        The traditional narrative is that typed languages are strict, rigid, and inexpressive. 
                        Sure they remove some bugs but they can feel constraining. 
                        People often say that they prefer prototyping in dynamic programming languages because the type system doesn't get in their way.

                        And it is true that there are valid programs that are not type safe. It turns out there is a trade off in computer science between saftey and expressiveness. There are more valid programs than those that type check.
                        However, the programs that type check are certain to be free of a huge swath of bugs.
                        There are many valid type systems, and as they get more expressive the gap between valid programs and typable programs shrinks. 

                        JavaScript is a highly dynamic and expressive language. We don't want to lose that. 
                        TypeScript also has a powerful, expressive, and flexible type system to match javascript. 
                    </aside>
                </section>
                <section>
                    <h2>JavaScript with Types</h2>
                    <table style="width: 100%;">
                        <tr><th style="text-align: center;">JavaScript</th><th style="text-align: center;">TypeScript</th></tr>
                    <tr><td>
                    <pre><code class="javascript">
var a = 1;
var b = true;
var c = "test";
var d = null;
var e = undefined;
var f = [1,2,3];
var g = ["one","two"];
var h = new Date();
var i = Symbol("foo")
                    </code></pre>
                    </td>
                    <td>
                    <pre><code class="typescript">
var a: number = 1;
var b: boolean = true;
var c: string = "test";
var d: null = null;
var e: undefined = undefined;
var f: number[] = [1,2,3]
var g: string[] = ["one","two"]
var h: Date = new Date();
var i: symbol = Symbol("foo")
                    </code></pre>
                    </td>
                    </tr>
                    </table>
                    <aside class="notes">
                        These are the basic data types in JavaScript and their names in TypeScript. Lets go over these one by one. 
                    </aside>
                </section>
                <section>
                    <h2>What happens when we get things wrong</h2>

                    <pre><code class="typescript">
var a: number = "test";
var b: boolean = 3;
var c: string = false;
                    </code></pre>
                    <pre>
example.ts|1 col 5 error| Type 'string' is not assignable to type 'number'.
example.ts|2 col 5 error| Type 'number' is not assignable to type 'boolean'.
example.ts|3 col 5 error| Type 'boolean' is not assignable to type 'string'.
                    </pre>
                    <aside class="notes">
                    Using a type system is easy. You probably know the phrase square peg in a round hole. Well with a type system the goal is to always put the square peg ino the square hole. That's it. 
                    </aside>
                </section>
                <section>
                    <h2>functions</h2>
                    <pre><code class="javascript">
function sum(x, y) {
    return x + y;
}
                    </code></pre>

                    <h2>function types</h2>

                    <pre><code class="typescript">
function sum(x: number, y: number): number {
    return x + y;
}
                    </code></pre>
                    <aside class="notes">
                    Tthis is how we describe functions. The parameters of a function get a type. The function also get a return type. 
                    </aside>
                </section>
                <section>
                    <h2>objects</h2>
                    <pre><code class="javascript">
var point1 = {
    x: 1,
    y: 4,
    name: "start"
};
                    </code></pre>
                    <h4>object types</h4>
                    <pre><code class="typescript">
var point1: {x: number, y: number, z?: number, name: string} = {
    x: 1,
    y: 4,
    name: "start"
};
                    </code></pre>
                    <p> The ? after property names indicates the property is optional </p>

                    <aside class="notes">
                        We create objects all the time in javascript. The important feature here is that for every property we expect our object to have, we also define the type. 
                    </aside>
                </section>
                <section>
                    <h2>Type Aliases</h2>
                    <pre><code class="typescript">
type Point = {x: number, y: number, z?: number, name: string};
var point1: Point = {
    x: 1,
    y: 4,
    name: "start"
};
var point2: Point = {
    x: 4,
    y: 10,
    z: -1,
    name: "end"
};
                    </code></pre>
                    <aside class="notes">
                        If we plan on making more than one of some type of object we don't want to type all of that type information out for each one, so we can use type aliases to no repeat ourselves. 
                    </aside>
                </section>
                <section>
                    <h2>String Literal Types</h2>
                    <p>You can treat string constants as types.</p>
                    <pre><code class="typescript">
type PrimaryColor = "red" | "blue" | "green";
function adjustColor(color: PrimaryColor, value: number) { /* */ }
adjustColor("red", 123) //ok
adjustColor("purple", 255) //Error
                    </pre></code>
                    
                    <aside class="notes">
                        Here we are beginning to lift specific values in javascript up to the type level. 
                    </aside>
                </section>
                <section>
                    <h2>Enums</h2>
                    <p>You can create named numeric contants with enums</p>
                    <pre><code class="typescript">
enum Directions {
    Up=1,
    Down,
    Left,
    Right
}

function Go(d: Directions): string {
    return "You went " + Directions[d] + " aka " + d;
}

Go(Directions.Left); //You went left aka 3
                </pre></code>
                </section>
                <section>
                    <h2>Numeric Literal Types</h2>
                    <pre><code class-"typescript">
type EightBit = 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7;
let coolbit: EightBit = 7; //ok
let badbit: EightBit = 8; //ok
                    </code></pre>
                </section>
                <section>
                    <h2>Type Aliases</h2>
                    <p>Type aliases can be used to alias primitives, which can be useful for documentation</p>
                    <pre><code class="typescript">
type Dollars = number;
type Name = string;
function BankBalance(person: Name): Dollars {
    return 3.50
}
                    </code></pre>
                </section>

                <section>
                    <h2>Classes</h2>
                    <p>Typescript supports the es6 syntax for classes</p>
                    <pre><code class="typescript">
class Person {
    name: string;
    constructor(name: string) {
        this.name = name;
    }
}
class SoftwareEngineer extends Person {
    prog_language: string;
    constructor(name: string, prog_language: string) {
        super(name)
    }
}
var joeTester: Person = new SoftwareEngineer("Joe", "TypeScript");
                    </code></pre>
                </section>
                <section>
                    <h2>Class syntax</h2>
                    <p>Typescript simplifies the "this.property = property" pattern with the public keyword. It also supports private and protected attributes on classes,
                    but these are compiler enforced only.
                    </p>
                    <pre><code class="typescript">
class Person {
    name: string;
    constructor(public name: string) {}
}
class SoftwareEngineer extends Person {
    prog_language: string;
    constructor(public name: string, private prog_language: string) {
        super(name)
        this.prog_language = prog_language;
    }
}
                    </code></pre>
                </section>
                <section>
                    <h2>Indexable types</h2>
                    <p>Interfaces can also be used to describe container objects like arrays and objects</p>
                    <pre><code class="typescript">
interface PhoneBook {
    [phoneNumber: string]: Person
}
class Person {
    constructor(public name: string) {}
}
var yellowpages: PhoneBook = {
    "1112223333": new Person("John"),
    "3334445555": new Person("Jane")
}

interface GuestList {
    [index: number]: Person
}
var partylist: GuestList = [new Person("John"), new Person("Jane")]
                    </code></pre>
                </section>
                <section>
                    <h2>Immutable data</h2>
                    <p>Variables, classes, and interfaces can enforce immutability on variables and properties. TypeScript also comes with a ReadonlyArray<T> type. Only the compiler forbids reassignment. </p>
                    <pre><code class="typescript">
const example = true;
interface ImmutablePoint {
    readonly x: number;
    readonly y: number;
}
class Pet {
    constructor(public readonly name: string) {};
}
let hex_letters: ReadonlyArray< string > = ['A','B','C','D','E','F'];
                    </code></pre>
                </section>
                <section>
                    <h2>Tuple Types</h2>
                    <p>Tuples are a way to describe  fixed length arrays with types for each index.</p>
                    <pre><code class="typescript">
let person: [string, number] = ["John Smith", 30];
person = ["Jane Doe", 30]; //ok
person = [20, "Joe Tester"] // Error
                    </code></pre>
                </section>
                <section>
                    <h2>Union Types</h2>
                    <p>We can use union types to describe pieces of data that can be two or more types of data. The | operator lets us create a union of types.</p>
                    <pre><code class="typescript">
var password: string | number = "test"
password = 1234 //also ok!

function validatePassword(password: number | string): boolean {
    if(typeof number == "number") {
        return number > 1000;
    }else{
        return string.length > 4;
    }
}
                    </code></pre>
                </section>
                <section>
                    <h2>Intersection Types</h2>
                    <p>These allow you describe an object which is one type AND another type. A common JavaScript pattern called a the mixin pattern can be described with intersection types.</p>
                    <pre><code class="typescript">
type Fahrenheit = {fahrenheit: number};
type Celcius = {celcius: number};
function convertToCelcius(temp: Fahrenheit): Fahrenheit & Celcius {
    let c_temp = (temp.fahrenheit-32)*(5/9);
    temp.celcius = c_temp;
    return temp;
}
                    </code></pre>
                </section>
                <section>
                    <h2>Structural Typing</h2>
                    <p>Most languages traditional languages use a nominal typesystem, which means that the when they compare types they look at the name of the type to determine if an expression is well typed.</p>
                    
                    Typescript has a structural type system which means that it compares the shape of types rather than just the name.</p>
                </section>
                <section>
                    <h2>Structural Typing example</h2>
                    <pre><code class="typescript">
type Pet = {name: string, age: number};
type Person = {name: string, age: number};

function HappyBirthday(p: Person) {
    p.age++;
    console.log(`Happy Birthday ${p.name}!`+
        `You are now ${p.age} years old!`);
}
let myDoge = {name: "Spot", age: 4};
HappyBirthday(myDoge);
//Happy Birthday Spot! You are now 5 years old!
                    </code></pre>
                </section>
                <section>
                    <h2>Tsconfig</h2>
                    <p>Typescript has a config file you can generate for your project called "tsconfig.json".
                    Among other things, this file allows you to ramp up or ramp down strictness in typing.
                    Here is an example of a maximally strict config file.
                    <pre><code class="typescript">
{
    "compilerOptions": {
        "module": "commonjs",
        "sourceMap": true,
        "target": "ES6",
        "noImplicitAny": true,
        "noImplicitReturns": true,
        "noImplicitThis": true,
        "noFallthroughCasesInSwitch": true,
        "strictNullChecks": true
    }
}
                    </code></pre>
                </section>
                <section>
                    <h2>Control Flow Analysis</h2>
                    <p>Typescript can also prevent common errors because it understands how data and types flow through JavaScript.</p>
                    <pre><code class="typescript">
var test: number;
console.log(test); //error unassigned variable

function goTime(isGoTime: boolean) {
    if(isGoTime) {
        return isGoTime;
    }else{
        return !isGoTime;
    }
    return "asdf"; //error unreachable code
}

switch(test) {
    case 1:
        console.log("Hello world!"); //error switch case fall-through
    case 2:
        console.log("Goodnight world!");
        break;
    default:
        console.log("foobar");
}
                    </code></pre>
                </section>
                <section>
                    <h2>Additional Topics</h2>
                        <ul>
                            <li>Any, void, and never types</li>
                            <li>Type casting</li>
                            <li>Function type aliases, subtypes, and variance</li>
                            <li>Parametric (aka Generic) types</li>
                            <li>Parametric (aka Generic) type constraints</li>
                            <li>Mapped types</li>
                            <li>Lookup types</li>
                            <li>Type Guards</li>
                            <li>Discriminated unions</li>
                            <li>Modules</li>
                            <li>Interfaces</li>
                            <li>Abstract classes and methods</li>
                            <li>static class methods</li>
                            <li>JSX</li>
                        </ul>
                </section>
                <section>
                    <h2>Setup</h2>
                    <pre><code class="bash">
sudo npm install -g typescript
                    </pre></code>
                    <p>installs the command tsc</p>

                    <h2>How do you use it?</h2>
                    <pre><code class="bash">
tsc tilename.ts
                    </pre></code>
                    <p>Upon running tsc on a ts file it will generate a .js file of the same name, which is the translation of the typescript code</p>
                </section>
                <section>
                <h1>Resources</h1>
                <a href="www.typescriptlang.org">TypeScript homepage</a>
                <a href="http://www.typescriptlang.org/play/index.html">Online Playground</a>
                <a href="http://www.typescriptlang.org/docs/tutorial.html">Typescript Documentation</a>
                <a href="https://github.com/Microsoft/TypeScript/wiki">Typescript Wiki</a>
                <a href="https://github.com/typings/typings">Community Provided Types for libraries</a>
                </section>
            </div>
            </div>
            </div>
        </div>

        <script src="lib/js/head.min.js"></script>
        <script src="js/reveal.js"></script>

        <script>
            // More info https://github.com/hakimel/reveal.js#configuration
            Reveal.initialize({
                history: true,

                // More info https://github.com/hakimel/reveal.js#dependencies
                dependencies: [
                    { src: 'plugin/markdown/marked.js' },
                    { src: 'plugin/markdown/markdown.js' },
                    { src: 'plugin/notes/notes.js', async: true },
                    { src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
                ]
            });
        </script>
    </body>
</html>
